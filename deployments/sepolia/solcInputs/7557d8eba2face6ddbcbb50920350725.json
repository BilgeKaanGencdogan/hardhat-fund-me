{
    "language": "Solidity",
    "sources": {
        "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
        },
        "contracts/FundMe.sol": {
            "content": "// Get funds from users\n// Withdraw funds\n// Set a minimum funding value in USD\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"./PriceConvertor.sol\";\n\nerror NotOwner();\n\n// creating this contract costs 771,527 gas\ncontract FundMe {\n    using PriceConvertor for uint256;\n\n    //uint256 public number;\n\n    // when adding constant, this variable no longer takes a storage spot\n    // and much easier to read to\n    uint256 public constant MINIMUM_USD = 50 * 1e18;\n    // 347 gas - constant\n    // 2446 gas - non-constant\n\n    address[] public funders;\n    mapping(address => uint256) public addressToAmountFunded;\n\n    address public immutable i_owner;\n\n    // 439 gas - immutable\n    // 2574 gas - non-immutable\n\n    // For CONSTANT variables, the value has to be fixed at compile-time,\n    // while for IMMUTABLE , it can still be assigned at construction time.\n\n    // The reason that CONSTANT and IMMUTABLE save gas;\n    // because instead of storing variables inside storage slots\n    // we actually store them directly into the byte code of the contract.\n\n    AggregatorV3Interface public priceFeed;\n\n    constructor(address priceFeedAddress) {\n        i_owner = msg.sender;\n        priceFeed = AggregatorV3Interface(priceFeedAddress);\n    }\n\n    function fund() public payable {\n        // Want to able to set a minimum fund amount in USD\n        //1. how do we sen ETH to this contract?\n\n        //in order to make function payable with ETH any other native blockchain currency\n        // we need to mark the function as payable\n\n        //Smart contracts can hold funds just like how wallets can\n\n        // to get how much value someone's sending, you use msg global variable\n\n        // we tell people that they send at least 1 ETH with this below\n\n        //number = 5;\n\n        //require(msg.value > 1e18,\"Did not send enough!!\"); // 1e18 = 1 * 10 ** 18 == 1000000000000000000 Wei\n        // whole expression is equal to 1ETH\n        // Money math in done in terms of wei So 1ETH\n        // needs to be set as 1e18 value\n\n        // What is reverting?\n        // undo any action before, and send remaining gas back\n        // we spend gas to set number to 5, but after that any remaining gas would returned\n        // by this require when the condition is not met.\n        // and also any prior work undone, which means number is not set to 5 in that example.\n\n        //msg.value.getConversionRate(); equals getConversionRate(msg.value);\n\n        require(\n            msg.value.getConversionRate(priceFeed) >= MINIMUM_USD,\n            \"Did not send enough!\"\n        );\n\n        //msg.value.getConversionRate() even though function getConversionRate(uint256 ethAmount) in library(PriceConvertor.sol)\n        //waits the paramater, we do not pass but\n        //msg.value is considered as first paramater any of these library funcitons\n\n        //msg.value gonna have 18 decimal places\n\n        //to track the people who send money to this contract\n        funders.push(msg.sender);\n        addressToAmountFunded[msg.sender] += msg.value;\n    }\n\n    function withdraw() public onlyOwner {\n        for (\n            uint256 funderIndex = 0;\n            funderIndex < funders.length;\n            funderIndex++\n        ) {\n            address funder = funders[funderIndex];\n            addressToAmountFunded[funder] = 0;\n        }\n\n        //reset the array\n        funders = new address[](0);\n        //actually withdraw the funds\n        // how to actually withdraw funds from the contract ?\n        // how do we send funds back to whomever is calling this?\n\n        // To actually send ether or send native blockchain currency\n        // there are 3 ways to do that;\n        // 1. transfer\n        // 2. send\n        // 3. call\n\n        /* 1.TRANSFER */\n        // msg.sender is of type ADDRESS\n        // payable(msg.sender) is of type PAYABLE ADDRESS\n        // In Solidity, in order to send native blockchain token like ethereum;\n        // you can only work with payable address to do that.\n        // if this line fails, it gives error and revert the transaction\n        // https://solidity-by-example.org/sending-ether/\n        // payable(msg.sender).transfer(address(this).balance);\n\n        /* 2.SEND */\n        // Send does not automatically revet the transaction like Transfer\n        // In order to do that, we had to add require to revert transaction\n        // bool sendSuccess = payable(msg.sender).send(address(this).balance);\n        //require(sendSuccess,\"Send Failed\");\n\n        /* Call */\n        // returns 2 variables\n        // Since call allows us to actually call different functions\n        // if that functions returns some date or value, we are gonna save that in that\n        // dataReturned variable\n        // if the function is succesfully called, callSuccess is true, otherwise false.\n        (bool callSuccess /* bytes memory dataReturned */, ) = payable(\n            msg.sender\n        ).call{value: address(this).balance}(\"\");\n        require(callSuccess, \"Send Failed\");\n    }\n\n    modifier onlyOwner() {\n        //with writing that modifier in the function declariton, we say;\n        // before implementing all of code, implement require statement\n        // _; represents all code implementation\n        // if we put it after require, first implement require impelemantation\n        // then do the rest of work\n        // if we put it before, vice versa\n        // meaning that ordering is important!!\n\n        //require(msg.sender == i_owner,\"Sender is not owner!!\");\n        if (msg.sender != i_owner) {\n            revert NotOwner();\n        }\n        _;\n    }\n\n    // What happens if someone sends this contract ETH without calling the fund function?\n\n    // receive()\n    receive() external payable {\n        fund();\n    }\n\n    // fallback()\n    fallback() external payable {\n        fund();\n    }\n}\n"
        },
        "contracts/PriceConvertor.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConvertor {\n    // Libraries are similar to contracts, but you can't declare any state variable and you can't send ether.\n    // A library is embedded into the contract if all library functions are internal.\n    // Otherwise the library must be deployed and then linked before the contract is deployed.\n    // https://solidity-by-example.org/library/\n\n    function getPrice(\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        (\n            ,\n            /*uint80 roundID*/ int256 price /*uint startedAt*/ /*uint timeStamp*/ /*uint80 answeredInRound*/,\n            ,\n            ,\n\n        ) = priceFeed.latestRoundData();\n        // ETH in terms of USD\n        // ~ 3000.00000000\n        // msg.value and price here have different decimal places\n        //we have multiple price with 1e10 to match their unit\n        // because price has 8 decaimal places and msh.value has 18 decimal places\n        return uint256(price * 1e10); // 1**10= 10000000000\n        //also msg.value is uint256 but price is int256\n        // we need to convert price to be uint256 to match the types of these two variables\n    }\n\n    function getVersion() internal view returns (uint256) {\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            0x694AA1769357215DE4FAC081bf1f309aDC325306\n        );\n        return priceFeed.version();\n    }\n\n    function getConversionRate(\n        uint256 ethAmount,\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        uint256 ethPrice = getPrice(priceFeed);\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;\n        return ethAmountInUsd;\n    }\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": false,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.gasEstimates"
                ],
                "": ["ast"]
            }
        },
        "metadata": {
            "useLiteralContent": true
        }
    }
}
